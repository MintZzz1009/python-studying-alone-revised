# 복잡도

x = 10
print(x + 1)
# 덧셈 횟수: 1번

A = [1, 2, 3, 4, 5]
output = 0
for a in A:
    output += a
print(output)
# 덧셈 횟수: n번

# 2차원 배열의 요소를 더하는 프로그램
A = [
    [1, 2],
    [3, 4]
]
output = 0
for 리스트 in A:
    for i in 리스트:
         output += i
print(output)
# 덧셈 횟수: 4번(2 X 2) 리스트의 길이에 따라 N X N번 이루어짐



n = 1000000

# 점근표기법, 빅오 표기법, 란다우 표기법: O라는 함수로 감싸서 표기하는 방법.
# - 최고차 항만 남기고
# - 최고차 항의 계수를 제거하면

# 10n^2 + n => O(n^2)
# n^2 + 1 => O(n^2)
# 5n ==> O(n)
# O(n)
# O(1)


# 복잡도를 알아야 하는 이유?
# => 컴퓨터는 생각보다 느리다.

# 세계에서 제일 빠른 컴퓨터: 프론티어
# 1.12 엑사 플롭 급 : 1초에 112경 번의 부동소수점 연산

# 만약 알고리즘의 복잡도가 O(n!)이라면 어떨까?
# n = 32 일 때, 대충 10^35      # 1경 = 10^16   10경 = 10^17    100경 = 10^18

# 10^35 / 10^18 = 10^17초 정도 걸린다.
# == 1157407407407.4075 일
# == 3170979198.3764586 연도
10 ** 17 / (60 * 60 * 24 * 365)

# 그래서 어떤 알고리즘을 만들었는데, 복잡도가 n!이 나왔다면 이것은 현실적인 알고리즘이 아니다.
# n^2
# n * log n       이 정도가 현실적인 알고리즘인다.

# <프로그래밍이 가능한 컴퓨터의 역사>
# compute 계산하다 + er ~하는자 = computer 계산을 할 수 있는 존재
# 기원전에도 컴퓨터가 있었다.
# e.g. 안티키테라 -> 천문학 도구. 
# 활용시, 행성의 위치, 달의 모양, 일식의 날짜를 계산할 수 있다. 농사를 위해서 아주 필요한 기계.

# 파스칼 계산기 (10진법 사용)
# 라이프니츠 (곱세과 나눗셈 가능한 계산기. 2진법 도입)
# 찰스 배비지의 프로그래밍 가능한 컴퓨터
# 에이다 러브레이스의 조건문과 반복문과 서브루틴의 개념을 추가해서 최초의 프로그램을 만들었다.

# 최초의 고급 프로그래밍 언어 Plankalkul.
